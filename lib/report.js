const Exclude = require('test-exclude')
const convertSourceMap = require('convert-source-map');
const furi = require('furi')
const libCoverage = require('istanbul-lib-coverage')
const libReport = require('istanbul-lib-report')
const libSourceMaps = require("istanbul-lib-source-maps");
const reports = require('istanbul-reports')
const { readdirSync, readFileSync } = require('fs')
const { isAbsolute, resolve } = require('path')
// TODO: switch back to @c88/v8-coverage once patch is landed.
const { mergeProcessCovs } = require('@bcoe/v8-coverage')
const v8toIstanbul = require('v8-to-istanbul')

class Report {
  constructor ({
    globRoot,
    exclude,
    include,
    reporter,
    reportsDirectory,
    tempDirectory,
    watermarks,
    omitRelative,
    wrapperLength,
    resolve: resolvePaths
  }) {
    this.reporter = reporter
    this.reportsDirectory = reportsDirectory
    this.tempDirectory = tempDirectory
    this.watermarks = watermarks
    this.resolve = resolvePaths
    this.exclude = Exclude({
      cwd: globRoot,
      exclude: exclude,
      include: include
    });
    this.omitRelative = omitRelative
    this.wrapperLength = wrapperLength
    this.sourceMapCache = libSourceMaps.createSourceMapStore();
  }
  run () {
    const map = this.getCoverageMapFromAllCoverageFiles()
    var context = libReport.createContext({
      dir: this.reportsDirectory,
      watermarks: this.watermarks
    })

    const tree = libReport.summarizers.pkg(map)

    this.reporter.forEach(function (_reporter) {
      tree.visit(reports.create(_reporter), context)
    })
  }

  getCoverageMapFromAllCoverageFiles () {
    // the merge process can be very expensive, and it's often the case that
    // check-coverage is called immediately after a report. We memoize the
    // result from getCoverageMapFromAllCoverageFiles() to address this
    // use-case.
    if (this._allCoverageFiles) return this._allCoverageFiles

    const v8ProcessCov = this._getMergedProcessCov()

    const map = libCoverage.createCoverageMap({})

    for (const v8ScriptCov of v8ProcessCov.result) {
      try {
        const path = resolve(this.resolve, v8ScriptCov.url)
        const script = v8toIstanbul(path, this.wrapperLength)
        script.applyCoverage(v8ScriptCov.functions)
        map.merge(script.toIstanbul())
      } catch (err) {
        console.warn(`file: ${v8ScriptCov.url} error: ${err.stack}`)
      }

      try {
        const path = resolve(this.resolve, v8ScriptCov.url);
        const sourceMap = convertSourceMap.fromSource(
          readFileSync(path, "utf8")
        );
        if (sourceMap) {
          this.sourceMapCache.registerMap(
            path,
            sourceMap.sourcemap
          );
        }
      } catch (err) {
        console.warn(`file: ${v8ScriptCov.url} source map error: ${err.stack}`)
      }
    }


    map.data = this._remapCoverage(map.data);

    this._allCoverageFiles = map
    return this._allCoverageFiles
  }

  /**
   * Returns the merged V8 process coverage.
   *
   * The result is computed from the individual process coverages generated
   * by Node. It represents the sum of their counts.
   *
   * @return {ProcessCov} Merged V8 process coverage.
   * @private
   */
  _getMergedProcessCov () {
    const v8ProcessCovs = []
    for (const v8ProcessCov of this._loadReports()) {
      v8ProcessCovs.push(this._normalizeProcessCov(v8ProcessCov))
    }
    return mergeProcessCovs(v8ProcessCovs)
  }

  /**
   * Returns the list of V8 process coverages generated by Node.
   *
   * @return {ProcessCov[]} Process coverages generated by Node.
   * @private
   */
  _loadReports () {
    const files = readdirSync(this.tempDirectory)

    return files.map((f) => {
      try {
        return JSON.parse(readFileSync(
          resolve(this.tempDirectory, f),
          'utf8'
        ))
      } catch (err) {
        console.warn(`${err.stack}`)
      }
    })
  }

  /**
   * Normalizes a process coverage.
   *
   * This function replaces file URLs (`url` property) by their corresponding
   * system-dependent path and applies the current inclusion rules to filter out
   * the excluded script coverages.
   *
   * The result is a copy of the input, with script coverages filtered based
   * on their `url` and the current inclusion rules.
   * There is no deep cloning.
   *
   * @param v8ProcessCov V8 process coverage to normalize.
   * @return {v8ProcessCov} Normalized V8 process coverage.
   * @private
   */
  _normalizeProcessCov (v8ProcessCov) {
    const result = []
    for (const v8ScriptCov of v8ProcessCov.result) {
      if (/^file:\/\//.test(v8ScriptCov.url)) {
        try {
          v8ScriptCov.url = furi.toSysPath(v8ScriptCov.url)
        } catch (err) {
          console.warn(err)
          continue
        }
      }
      if (this.exclude.shouldInstrument(v8ScriptCov.url) &&
        (!this.omitRelative || isAbsolute(v8ScriptCov.url))) {
        result.push(v8ScriptCov)
      }
    }
    return { result }
  }

  _remapCoverage (obj) {
    const transformed = this.sourceMapCache.transformCoverage(
      libCoverage.createCoverageMap(obj)
    )
    return transformed.map.data    
  }
}

module.exports = function (opts) {
  return new Report(opts)
}
