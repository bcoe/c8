const Exclude = require('test-exclude')
const furi = require('furi')
const libCoverage = require('istanbul-lib-coverage')
const libReport = require('istanbul-lib-report')
const reports = require('istanbul-reports')
const { readdirSync, readFileSync } = require('fs')
const { isAbsolute, resolve } = require('path')
// TODO: switch back to @c88/v8-coverage once patch is landed.
const { mergeProcessCovs } = require('@bcoe/v8-coverage')
const v8toIstanbul = require('v8-to-istanbul')
const isCjsEsmBridgeCov = require('./is-cjs-esm-bridge')

class Report {
  constructor ({
    exclude,
    include,
    reporter,
    reportsDirectory,
    tempDirectory,
    watermarks,
    omitRelative,
    wrapperLength,
    resolve: resolvePaths
  }) {
    this.reporter = reporter
    this.reportsDirectory = reportsDirectory
    this.tempDirectory = tempDirectory
    this.watermarks = watermarks
    this.resolve = resolvePaths
    this.exclude = Exclude({
      exclude: exclude,
      include: include
    })
    this.omitRelative = omitRelative
    this.wrapperLength = wrapperLength
  }

  async run () {
    const map = await this.getCoverageMapFromAllCoverageFiles()
    var context = libReport.createContext({
      dir: this.reportsDirectory,
      watermarks: this.watermarks
    })

    const tree = libReport.summarizers.pkg(map)

    this.reporter.forEach(function (_reporter) {
      tree.visit(reports.create(_reporter), context)
    })
  }

  async getCoverageMapFromAllCoverageFiles () {
    // the merge process can be very expensive, and it's often the case that
    // check-coverage is called immediately after a report. We memoize the
    // result from getCoverageMapFromAllCoverageFiles() to address this
    // use-case.
    if (this._allCoverageFiles) return this._allCoverageFiles

    const v8ProcessCov = this._getMergedProcessCov()
    const map = libCoverage.createCoverageMap({})
    const resultCountPerPath = new Map()
    const possibleCjsEsmBridges = new Map()

    for (const v8ScriptCov of v8ProcessCov.result) {
      try {
        const path = resolve(this.resolve, v8ScriptCov.url)
        const converter = v8toIstanbul(path, this.wrapperLength)
        await converter.load()

        if (resultCountPerPath.has(path)) {
          resultCountPerPath.set(path, resultCountPerPath.get(path) + 1)
        } else {
          resultCountPerPath.set(path, 0)
        }

        if (isCjsEsmBridgeCov(v8ScriptCov)) {
          possibleCjsEsmBridges.set(converter, {
            path,
            functions: v8ScriptCov.functions
          })
        } else {
          converter.applyCoverage(v8ScriptCov.functions)
          map.merge(converter.toIstanbul())
        }
      } catch (err) {
        console.warn(`file: ${v8ScriptCov.url} error: ${err.stack}`)
      }
    }

    for (const [converter, { path, functions }] of possibleCjsEsmBridges) {
      if (resultCountPerPath.get(path) <= 1) {
        converter.applyCoverage(functions)
        map.merge(converter.toIstanbul())
      }
    }

    this._allCoverageFiles = map
    return this._allCoverageFiles
  }

  /**
   * Returns the merged V8 process coverage.
   *
   * The result is computed from the individual process coverages generated
   * by Node. It represents the sum of their counts.
   *
   * @return {ProcessCov} Merged V8 process coverage.
   * @private
   */
  _getMergedProcessCov () {
    const v8ProcessCovs = []
    for (const v8ProcessCov of this._loadReports()) {
      if (this._isCoverageObject(v8ProcessCov)) {
        v8ProcessCovs.push(this._normalizeProcessCov(v8ProcessCov))
      }
    }
    return mergeProcessCovs(v8ProcessCovs)
  }

  /**
   * Make sure v8ProcessCov actually contains coverage information.
   *
   * @return {boolean} does it look like v8ProcessCov?
   * @private
   */
  _isCoverageObject (maybeV8ProcessCov) {
    return maybeV8ProcessCov && Array.isArray(maybeV8ProcessCov.result)
  }

  /**
   * Returns the list of V8 process coverages generated by Node.
   *
   * @return {ProcessCov[]} Process coverages generated by Node.
   * @private
   */
  _loadReports () {
    const files = readdirSync(this.tempDirectory)

    return files.map((f) => {
      try {
        return JSON.parse(readFileSync(
          resolve(this.tempDirectory, f),
          'utf8'
        ))
      } catch (err) {
        console.warn(`${err.stack}`)
      }
    })
  }

  /**
   * Normalizes a process coverage.
   *
   * This function replaces file URLs (`url` property) by their corresponding
   * system-dependent path and applies the current inclusion rules to filter out
   * the excluded script coverages.
   *
   * The result is a copy of the input, with script coverages filtered based
   * on their `url` and the current inclusion rules.
   * There is no deep cloning.
   *
   * @param v8ProcessCov V8 process coverage to normalize.
   * @return {v8ProcessCov} Normalized V8 process coverage.
   * @private
   */
  _normalizeProcessCov (v8ProcessCov) {
    const result = []
    for (const v8ScriptCov of v8ProcessCov.result) {
      if (/^file:\/\//.test(v8ScriptCov.url)) {
        try {
          v8ScriptCov.url = furi.toSysPath(v8ScriptCov.url)
        } catch (err) {
          console.warn(err)
          continue
        }
      }
      if (this.exclude.shouldInstrument(v8ScriptCov.url) &&
        (!this.omitRelative || isAbsolute(v8ScriptCov.url))) {
        result.push(v8ScriptCov)
      }
    }
    return { result }
  }
}

module.exports = function (opts) {
  return new Report(opts)
}
