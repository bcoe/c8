const parser = require('yargs-parser')

/**
 * Function: printConfig
 *
 * @param {Object} yargs: instance of populated yargs object.
 * @param {Function} hideInstrumenteeArgs: Callback defined in lib/parse-args.
 * @returns {undefined}
 *
 * Entry point for print config logic from lib/parse-args.js file.
 * Kills process at the end of execution.
 *
 */
function printConfig (yargs, hideInstrumenteeArgs) {
  const argv = process.argv.slice(2)
  const checkArgs = parser(argv)

  let shouldPrint = false

  if (Object.keys(checkArgs).includes('print-config')) {
    // checkArgs['print-config'] could contain a boolean or a string
    // representing a boolean.
    if (typeof checkArgs['print-config'] === 'boolean') {
      shouldPrint = checkArgs['print-config']
    } else if (typeof checkArgs['print-config'] === 'string') {
      shouldPrint = JSON.parse(checkArgs['print-config'])
    }
  }

  if (shouldPrint) {
    const args = yargs.parse(hideInstrumenteeArgs())
    const cmdExecuted = 'c8 ' + argv.join(' ')
    const cleanArgs = cleanUpArgumentObject(args)

    if (args.printConfigFormat === 'text') {
      printConfigText(cleanArgs, cmdExecuted)
    } else if (checkArgs.printConfigFormat === 'json') {
      const jsonYargs = JSON.stringify(cleanArgs, 2)
      console.log(jsonYargs)
    }

    // DO NOT REMOVE!  This is intentional.
    process.exit()
  }
}

/**
 * Function: cleanUpArgumentObject
 *
 * @param {Object} args: key/value pairs of configuration options
 *  generated by yargs.parse().
 * @returns {Object} - Clone of args with duplicated data removed.
 *
 * This function exclude duplicate values that have different keys.
 * Additionally, scrubs convenience key values.
 *
 * For example: args['temp-directory'] and args['tempDirectory']
 * are essentially the same variable.
 *
 */
function cleanUpArgumentObject (args) {
  const argsToPrint = {}

  const keysToIterate = Object.keys(args).filter(v => {
    return (!['_', '$0'].includes(v) && v.length > 1)
  })

  const camelCaseKeys = keysToIterate.filter(x => {
    return [...x.matchAll(/([A-Z])/g)].length > 0
  })

  keysToIterate.forEach(v => {
    if (camelCaseKeys.includes(v)) {
      // Derive Kebab Case string from Camel Case Key string
      const newKey = v.replace(/([A-Z])/g, '-$1').toLowerCase()
      // If the Kebab Case key is not assigned a value
      if (!args[newKey]) {
        // Then assigned it the Camel Case Variable
        argsToPrint[newKey] = args[v]
      }
    } else {
      // Just keep the value.  Either Kebab case or otherwise
      argsToPrint[v] = args[v]
    }
    // Not sure if we will hit this scenario
    // should we throw an error?
  })

  return argsToPrint
}

/**
 * Function: printConfigText
 *
 * @param {Object} argsv: sanitized configuration option object.
 * @param {String} cmdExecuted: the string representing the
 *  command for c8 that passed to the cli.
 * @returns {undefined}
 *
 */
function printConfigText (argsv, cmdExecuted) {
  const configFilePath = argsv instanceof Object &&
    Object.keys(argsv).includes('config') && argsv.config
    ? argsv.config
    : ''

  // get the table string and add some padding
  const tablePadding = '    '

  // Adding padding to right side of table display
  const table = printConfigTable(argsv, tablePadding)

  // find the line in the table with the most characters
  const tableWidth = longestColumn(table)

  const description = printTableDescription(tableWidth, tablePadding)

  // get the banner string
  const banner = printConfigBanner(cmdExecuted, configFilePath, tableWidth, tablePadding)

  // now print
  console.log(banner)
  console.log(description)
  console.log(table)
}

/**
 * Function: printConfigBanner
 *
 * @param {String} cmdExecuted: the string representing the
 *  command for c8 that passed to the cli.
 * @param {String} configFilePath: the absolute path to
 *  the configuration file that was loaded.
 * @param {Number} tableWidth: the maximum table with measured by
 *  the number of characters.
 * @param {String} tablePadding: a whitespace string to add as
 *   padding to the entire table.
 * @returns {String} - the banner string to print.
 *
 * Todo:
 *  1.  Should I center this using the process.stdout.columns variable?
 *
 */
function printConfigBanner (cmdExecuted, configFilePath, tableWidth, tablePadding) {
  const graphic = String.raw`


    /* ________/\\\\\\\\\_        _____/\\\\\\\\\____         */
    /*  _____/\\\////////__        ___/\\\///////\\\__        */
    /*   ___/\\\/___________        __\/\\\_____\/\\\__       */
    /*    __/\\\_____________        __\///\\\\\\\\\/___      */
    /*     _\/\\\_____________        ___/\\\///////\\\__     */
    /*      _\//\\\____________        __/\\\______\//\\\_    */
    /*       __\///\\\__________        _\//\\\______/\\\__   */
    /*        ____\////\\\\\\\\\_        __\///\\\\\\\\\/___  */
    /*         _______\/////////__        ____\/////////_____ */
  `

  const graphicWidth = longestColumn(graphic)

  const graphicPaddingNum = Math.floor((tableWidth - graphicWidth) / 2)
  const graphicPaddingStr = charString(graphicPaddingNum) + tablePadding

  const summery = String.raw`
    Command Issued:     ${cmdExecuted}
    Config File Loaded: ${configFilePath}

  `

  const reg = /\n{1} +/g
  const replacement = '\n' + graphicPaddingStr

  const banner = graphic + summery

  return banner.replace(reg, replacement)
}

/**
 * Function: printTableDescription
 *
 * @param {Number} tableWidth: A number representing the column
 *   length of the configuration table.
 * @param {String} tablePadding: a whitespace string to add as
 *   padding to the entire table.
 * @returns {String} - A string representing the configuration
 *   table's description.
 *
 */
function printTableDescription (tableWidth, tablePadding) {
  const description = tablePadding +
    'Derived Configuration from CLI options and configuration file'
  const line = '\n' + tablePadding + charString(tableWidth, '-') + '\n'

  return description + line
}

/**
 * Function: charString
 *
 * @param {Number} num: a digit for the number of character
 * @returns {String} - a string with char repeated equal
 *  to the parameter num.
 */
function charString (num, char = ' ') {
  let str = ''
  for (let i = 0; i < num; i++) str += char
  return str
}

/**
 * Function: printConfigTable
 *
 * @param {Object} args: An object of config params processed by
 *  cleanUpArgumentObject function.
 * @param {String} tablePadding = '': A String representing the amount
 *   of right padding of the configuration value table.
 * @returns {String} - A string representing the current configuration.
 *
 */
function printConfigTable (args, tablePadding = '') {
  let output = ''
  const headerPadding = 10
  const headerColWidth = tableCalcHeaderWidth(args) + headerPadding

  Object.keys(args).forEach(v => {
    const headerText = v
    const value = args[v]
    output += printConfigTableRow(headerText, value, headerColWidth, tablePadding)
  })

  return output
}

/**
 * Function: tableCalcHeaderWidth
 *
 * @param {Object} args: An object of config params processed by
 *  cleanUpArgumentObject function.
 * @returns {Number} - An integer representing the max length of
 *  all keys assigned to the args object.
 *
 *
 */
function tableCalcHeaderWidth (args) {
  return longestColumn(Object.keys(args))
}

/**
 * Function: printConfigTableRow
 *
 * @param {String} header: a key in the arguments object.
 * @param {any} value: a value in the arguments object.
 * @param {Number} headerColWidth: max string length of keys in
 *  arguments object plus padding.
 * @param {String} tablePadding: A String representing the amount
 *   of right padding of the configuration value table.
 * @returns {String} - A rendered row of config table.
 *
 */
function printConfigTableRow (header, value, headerColWidth, tablePadding) {
  const { valueMargin, headerMargin } =
    tableCalcRowMargin(headerColWidth, header, tablePadding)

  const val = formatPrintVariable(value, valueMargin)
  const output = tablePadding + String(header) + ':' + headerMargin + val + '\n'

  return output
}

/**
 * Function: tableCalcRowMargin
 *
 * @param {Number} headerWidth: The width of the header column.
 * @param {String} headerText: The value of the header column.
 * @param {String} tablePadding: A String representing the amount
 *   of right padding of the configuration value table.
 * @returns {Object} - An object containing whitespace string
 *  padding for the value and header columns.
 *
 */
function tableCalcRowMargin (headerWidth, headerText, tablePadding) {
  const rowHeaderLength = headerWidth - headerText.length
  const rowHeaderMargin = charString(rowHeaderLength)

  const rowValueMargin = charString(headerWidth) + tablePadding

  return {
    valueMargin: rowValueMargin,
    headerMargin: rowHeaderMargin
  }
}

/**
 * Function: formatPrintVariable
 *
 * @param {any} variable: the variable to format.
 * @param {String} space: a string containing a variable
 *  amount of blank spaces.
 * @returns {String} - string representation of the variable.
 *
 *
 */
function formatPrintVariable (vars, space) {
  let value

  // Todo: I feel this would be easier to read a switch statement
  if (vars instanceof Array && vars.length >= 1) {
    value = stringifyObject(vars, space, ']')
  } else if (vars instanceof Array && vars.length === 0) {
    value = '[]'
  } else if (vars instanceof Object && Object.keys(vars).length >= 1) {
    value = stringifyObject(vars, space, '}')
  } else if (vars instanceof Object && Object.keys(vars).length === 0) {
    value = '{}'
  } else if (typeof vars === 'string' && vars) {
    value = "'" + vars + "'"
  } else if (typeof vars === 'string' && !vars) {
    value = "''"
  } else {
    value = vars
  }

  return value
}

/**
 * Function: stringifyObject
 *
 * @param {any} variable: the variable to format.
 * @param {String} space: string containing a variable
 *  amount of blank spaces.
 * @param {String} closingChar: single string character
 *  either a ']' or a '}'.
 * @returns {String} - string representation of the variable.
 *
 *
 */
function stringifyObject (variable, space, closingChar) {
  const calcTabs = (spaces) => {
    // 8 and 3 seem lie arbitrary numbers.  A tab should
    // equal 4 characters on all platforms.
    const numOfTabs = Math.floor(spaces.length / 8)
    const numOfSpaces = spaces.length % 8
    const tabs = charString(numOfTabs, '\t')
    const remainingSpaces = charString(numOfSpaces + 3)
    return tabs + remainingSpaces
  }

  const jsonTabs = calcTabs(space)

  const closeReg = new RegExp('\n' + closingChar, 'g')
  const out = JSON.stringify(variable, null, jsonTabs)
    .replace(closeReg, '\n' + space + ' ' + closingChar)

  return out
}

/**
 * Function: longestColumn
 *
 * @param {Array|String} text: a string containing linefeed
 *   characters or an array containing no linefeed characters.
 * @returns {Number} - a number representing the longest column
 *   width.
 *
 */
function longestColumn (text) {
  const compute = (text instanceof Array)
    ? [...text]
    : [...text.split('\n')]

  return compute.map(x => String(x).length)
    .reduce((curr, prev) => curr >= prev ? curr : prev)
}

module.exports = {
  printConfig,
  formatPrintVariable,
  cleanUpArgumentObject,
  printConfigText,
  longestColumn
}
